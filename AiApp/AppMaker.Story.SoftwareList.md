1. SOLID Principles
2. DRY (Don't Repeat Yourself) Principle
3. KISS (Keep It Simple, Stupid) Principle
4. YAGNI (You Aren't Gonna Need It) Principle
5. Event-Driven Architecture
6. Domain-Driven Design
7. Hexagonal Architecture (Ports and Adapters)
8. Layered Architecture
9. CQRS (Command Query Responsibility Segregation)
10. Event Sourcing
11. Clean Architecture
12. Software Craftsmanship
13. MVP (Model-View-Presenter) Design Pattern
14. MVVM (Model-View-ViewModel) Design Pattern
15. MVC (Model-View-Controller) Design Pattern
16. Pair Programming
17. Mob Programming
18. Code Katas for Regular Practice
19. Regular Refactoring
20. Using Design Patterns Appropriately
21. Software Anti-patterns Awareness
22. Tuckman's Stages of Team Development (Forming, Storming, Norming, Performing)
23. Agile Team Roles (Scrum Master, Product Owner, Developer)
24. Use of User Stories and Acceptance Criteria
25. Shared Understanding through Story Mapping
26. Regular Stand-ups (Daily Scrum)
27. Regular Retrospectives for Continuous Improvement
28. Building a Culture of Psychological Safety
29. Remote Work Best Practices
30. Use of a Definition of Done
31. Backlog Management and Prioritization Techniques
32. Timeboxing Technique
33. Pomodoro Technique for Focused Work Sessions
34. Fist of Five Voting Technique in Meetings
35. TDD and Red-Green-Refactor Cycle
36. BDD and Example Mapping
37. Tracer Bullet Development
38. Prototyping and Rapid Iterations
39. Spikes for Exploration and Learning
40. A/B Testing and Hypothesis-Driven Development
41. Value Stream Mapping
42. Code Smells and Refactoring Techniques
43. Continuous Feedback and Feed-forward Loops
44. Risk-First Software Development
45. High-Performance Team Characteristics
46. Principles of Effective Communication within Teams
47. Shared Code Ownership
48. Inner Source: Applying Open Source Practices within Organizations
49. Data-Driven Decision Making
50. Distributed Systems Design Patterns
51. Understanding and Applying CAP theorem
52. Applying 12-factor app principles
53. Strategic and Tactical DDD
54. Saga Pattern for Long-lived Transactions
55. API-First Design
56. Onion Architecture
57. Conway's Law and Organizational Design
58. High Cohesion and Low Coupling
59. Code Climate and Health Metrics
60. Database Design Principles and Normalization
61. Monoliths vs Microservices vs Nanoservices
62. Service Meshes and their use cases
63. Understanding Fallacies of Distributed Computing
64. Software Versioning and Semantic Versioning
65. Applying Backpressure in Systems Design
66. Use of Circuit Breakers and Bulkheads in Resiliency
67. Readiness and Liveness Probes in Kubernetes
68. Zero-Downtime Deployments
69. The concept of Data Gravity
70. API Gateway Pattern
71. Backend For Frontend Pattern (BFF)
72. Application of Strangler Fig Pattern for Migration
73. Decentralized Data Management in Microservices
74. Use of Correlation IDs for Distributed Tracing
75. Applying Observability in Distributed Systems
76. Use of Health Checks in Systems Design
77. Load Testing and Stress Testing